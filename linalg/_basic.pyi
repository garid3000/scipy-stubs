"""
This type stub file was generated by pyright.
"""

import numpy as np
import numpy.typing as npt
import scipy._typing as spt
from typing import Literal, TypeAlias, overload

__all__ = ["det", "inv", "lstsq", "matmul_toeplitz", "matrix_balance", "pinv", "pinvh", "solve", "solve_banded", "solve_circulant", "solve_toeplitz", "solve_triangular", "solveh_banded"]
_Array_fc: TypeAlias = np.ndarray[tuple[int, ...], np.dtype[np.inexact[npt.NBitBase]]]
_Array_fc_0d: TypeAlias = np.ndarray[tuple[()], np.dtype[np.inexact[npt.NBitBase]]]
_Array_fc_1d: TypeAlias = np.ndarray[tuple[int], np.dtype[np.inexact[npt.NBitBase]]]
_Array_fc_2d: TypeAlias = np.ndarray[tuple[int, int], np.dtype[np.inexact[npt.NBitBase]]]
lapack_cast_dict: dict[str, str]
def solve(a: npt.ArrayLike, b: npt.ArrayLike, lower: bool = ..., overwrite_a: bool = ..., overwrite_b: bool = ..., check_finite: bool = ..., assume_a: Literal["gen", "sym", "her", "pos"] = ..., transposed: bool = ...) -> _Array_fc_2d:
    ...

def solve_triangular(a: npt.ArrayLike, b: npt.ArrayLike, trans: Literal[0, "N", 1, "T", 2, "C"] = ..., lower: bool = ..., unit_diagonal: bool = ..., overwrite_b: bool = ..., check_finite: bool = ...) -> _Array_fc_1d | _Array_fc_2d:
    ...

def solve_banded(l_and_u: npt.ArrayLike, ab: npt.ArrayLike, b: npt.ArrayLike, overwrite_ab: bool = ..., overwrite_b: bool = ..., check_finite: bool = ...) -> _Array_fc_1d | _Array_fc_2d:
    ...

def solveh_banded(ab: npt.ArrayLike, b: npt.ArrayLike, overwrite_ab: bool = ..., overwrite_b: bool = ..., lower: bool = ..., check_finite: bool = ...) -> _Array_fc_1d | _Array_fc_2d:
    ...

def solve_toeplitz(c_or_cr: npt.ArrayLike | tuple[npt.ArrayLike, npt.ArrayLike], b: npt.ArrayLike, check_finite: bool = ...) -> _Array_fc_1d | _Array_fc_2d:
    ...

def solve_circulant(c: npt.ArrayLike, b: npt.ArrayLike, singular: Literal["lstsq", "raise"] = ..., tol: spt.AnyReal | None = ..., caxis: spt.AnyInt = ..., baxis: spt.AnyInt = ..., outaxis: spt.AnyInt = ...) -> _Array_fc:
    ...

def inv(a: npt.ArrayLike, overwrite_a: bool = ..., check_finite: bool = ...) -> _Array_fc_2d:
    ...

def det(a: npt.ArrayLike, overwrite_a: bool = ..., check_finite: bool = ...) -> np.inexact[npt.NBitBase] | _Array_fc:
    ...

def lstsq(a: npt.ArrayLike, b: npt.ArrayLike, cond: spt.AnyReal | None = ..., overwrite_a: bool = ..., overwrite_b: bool = ..., check_finite: bool = ..., lapack_driver: Literal["gelsd", "gelsy", "gelss"] | None = ...) -> tuple[_Array_fc_1d | _Array_fc_2d, _Array_fc_0d | _Array_fc_1d, int, _Array_fc | None]:
    ...

@overload
def pinv(a: npt.ArrayLike, *, atol: spt.AnyReal | None = ..., rtol: spt.AnyReal | None = ..., return_rank: Literal[False] = ..., check_finite: bool = ...) -> _Array_fc_2d:
    ...

@overload
def pinv(a: npt.ArrayLike, *, atol: spt.AnyReal | None = ..., rtol: spt.AnyReal | None = ..., return_rank: Literal[True], check_finite: bool = ...) -> tuple[_Array_fc_2d, int]:
    ...

@overload
def pinvh(a: npt.ArrayLike, atol: spt.AnyReal | None = ..., rtol: spt.AnyReal | None = ..., lower: bool = ..., return_rank: Literal[False] = ..., check_finite: bool = ...) -> _Array_fc_2d:
    ...

@overload
def pinvh(a: npt.ArrayLike, atol: spt.AnyReal | None = ..., rtol: spt.AnyReal | None = ..., lower: bool = ..., *, return_rank: Literal[True], check_finite: bool = ...) -> tuple[_Array_fc_2d, int]:
    ...

@overload
def pinvh(a: npt.ArrayLike, atol: spt.AnyReal | None, rtol: spt.AnyReal | None, lower: bool, return_rank: Literal[True], check_finite: bool = ...) -> tuple[_Array_fc_2d, int]:
    ...

@overload
def matrix_balance(A: npt.ArrayLike, permute: bool = ..., scale: bool = ..., separate: Literal[False] = ..., overwrite_a: bool = ...) -> tuple[_Array_fc_2d, _Array_fc_2d]:
    ...

@overload
def matrix_balance(A: npt.ArrayLike, permute: bool = ..., scale: bool = ..., *, separate: Literal[True], overwrite_a: bool = ...) -> tuple[_Array_fc_2d, tuple[_Array_fc_1d, _Array_fc_1d]]:
    ...

@overload
def matrix_balance(A: npt.ArrayLike, permute: bool, scale: bool, separate: Literal[True], overwrite_a: bool = ...) -> tuple[_Array_fc_2d, tuple[_Array_fc_1d, _Array_fc_1d]]:
    ...

def matmul_toeplitz(c_or_cr: npt.ArrayLike | tuple[npt.ArrayLike, npt.ArrayLike], x: npt.ArrayLike, check_finite: bool = ..., workers: int | None = ...) -> _Array_fc_1d | _Array_fc_2d:
    ...

