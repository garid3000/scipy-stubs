"""
This type stub file was generated by pyright.
"""

import numpy as np
import numpy.typing as npt
import optype.numpy as onpt
import scipy._typing as spt
from typing import Any, Literal, TypeAlias, overload
from typing_extensions import TypeVar
from numpy._typing import _ArrayLikeComplex_co, _ArrayLikeFloat_co, _ArrayLikeInt_co

__all__ = ["ai_zeros", "assoc_laguerre", "bei_zeros", "beip_zeros", "ber_zeros", "bernoulli", "berp_zeros", "bi_zeros", "clpmn", "comb", "digamma", "diric", "erf_zeros", "euler", "factorial", "factorial2", "factorialk", "fresnel_zeros", "fresnelc_zeros", "fresnels_zeros", "h1vp", "h2vp", "ivp", "jn_zeros", "jnjnp_zeros", "jnp_zeros", "jnyn_zeros", "jvp", "kei_zeros", "keip_zeros", "kelvin_zeros", "ker_zeros", "kerp_zeros", "kvp", "lmbda", "lpmn", "lpn", "lqmn", "lqn", "mathieu_even_coef", "mathieu_odd_coef", "obl_cv_seq", "pbdn_seq", "pbdv_seq", "pbvv_seq", "perm", "polygamma", "pro_cv_seq", "riccati_jn", "riccati_yn", "sinc", "stirling2", "y0_zeros", "y1_zeros", "y1p_zeros", "yn_zeros", "ynp_zeros", "yvp", "zeta"]
_T0 = TypeVar("_T0")
_T1 = TypeVar("_T1", default=_T0)
_tuple2: TypeAlias = tuple[_T0, _T0]
_tuple4: TypeAlias = tuple[_T0, _T1, _T1, _T1]
_tuple8: TypeAlias = tuple[_T0, _T1, _T1, _T1, _T1, _T1, _T1, _T1]
_ArrayT = TypeVar("_ArrayT", bound=onpt.Array)
_SCT = TypeVar("_SCT", bound=np.generic)
_scalar_or_array: TypeAlias = _SCT | onpt.Array[tuple[int, ...], _SCT]
_array_0d: TypeAlias = onpt.Array[tuple[()], _SCT]
_array_1d: TypeAlias = onpt.Array[tuple[int], _SCT]
_array_2d: TypeAlias = onpt.Array[tuple[int, int], _SCT]
_array: TypeAlias = onpt.Array[tuple[int, ...], _SCT]
_i1: TypeAlias = np.int8
_i2: TypeAlias = np.int16
_i4: TypeAlias = np.int32
_i8: TypeAlias = np.int64
_i: TypeAlias = _i1 | _i2 | _i4 | _i8
_f2: TypeAlias = np.float16
_f4: TypeAlias = np.float32
_f8: TypeAlias = np.float64
_f: TypeAlias = _f2 | _f4 | _f8 | np.longdouble
_c8: TypeAlias = np.complex64
_c16: TypeAlias = np.complex128
_c: TypeAlias = _c8 | _c16 | np.clongdouble
def diric(x: _ArrayLikeFloat_co, n: spt.AnyInt) -> npt.NDArray[np.floating[Any]]:
    ...

def jnjnp_zeros(nt: spt.AnyInt) -> _tuple4[_array_1d[_f8], _array_1d[_i4]]:
    ...

def jnyn_zeros(n: spt.AnyInt, nt: spt.AnyInt) -> _tuple4[_array_1d[_f8]]:
    ...

def jn_zeros(n: spt.AnyInt, nt: spt.AnyInt) -> _array_1d[_f8]:
    ...

def jnp_zeros(n: spt.AnyInt, nt: spt.AnyInt) -> _array_1d[_f8]:
    ...

def yn_zeros(n: spt.AnyInt, nt: spt.AnyInt) -> _array_1d[_f8]:
    ...

def ynp_zeros(n: spt.AnyInt, nt: spt.AnyInt) -> _array_1d[_f8]:
    ...

def y0_zeros(nt: spt.AnyInt, complex: spt.AnyBool = ...) -> _tuple2[_array_1d[_c16]]:
    ...

def y1_zeros(nt: spt.AnyInt, complex: spt.AnyBool = ...) -> _tuple2[_array_1d[_c16]]:
    ...

def y1p_zeros(nt: spt.AnyInt, complex: spt.AnyBool = ...) -> _tuple2[_array_1d[_c16]]:
    ...

def jvp(v: _ArrayLikeFloat_co, z: spt.AnyComplex, n: spt.AnyInt = ...) -> _scalar_or_array[_f4 | _f8 | _c8 | _c16]:
    ...

def yvp(v: _ArrayLikeFloat_co, z: spt.AnyComplex, n: spt.AnyInt = ...) -> _scalar_or_array[_f4 | _f8 | _c8 | _c16]:
    ...

def kvp(v: _ArrayLikeFloat_co, z: spt.AnyComplex, n: spt.AnyInt = ...) -> _scalar_or_array[_f4 | _f8 | _c8 | _c16]:
    ...

def ivp(v: _ArrayLikeFloat_co, z: spt.AnyComplex, n: spt.AnyInt = ...) -> _scalar_or_array[_f4 | _f8 | _c8 | _c16]:
    ...

def h1vp(v: _ArrayLikeFloat_co, z: spt.AnyComplex, n: spt.AnyInt = ...) -> _scalar_or_array[_f4 | _f8 | _c8 | _c16]:
    ...

def h2vp(v: _ArrayLikeFloat_co, z: spt.AnyComplex, n: spt.AnyInt = ...) -> _scalar_or_array[_f4 | _f8 | _c8 | _c16]:
    ...

def riccati_jn(n: spt.AnyInt, x: spt.AnyReal) -> _tuple2[_array_1d[_f8]]:
    ...

def riccati_yn(n: spt.AnyInt, x: spt.AnyReal) -> _tuple2[_array_1d[_f8]]:
    ...

def erf_zeros(nt: spt.AnyInt) -> _array_1d[_c16]:
    ...

def fresnelc_zeros(nt: spt.AnyInt) -> _array_1d[_c16]:
    ...

def fresnels_zeros(nt: spt.AnyInt) -> _array_1d[_c16]:
    ...

def fresnel_zeros(nt: spt.AnyInt) -> _array_1d[_c16]:
    ...

def assoc_laguerre(x: _ArrayLikeComplex_co, n: spt.AnyInt, k: spt.AnyReal = ...) -> _scalar_or_array[_f4 | _f8 | _c8 | _c16]:
    ...

def polygamma(n: _ArrayLikeInt_co, x: _ArrayLikeFloat_co) -> _scalar_or_array[_f8]:
    ...

def mathieu_even_coef(m: spt.AnyInt, q: spt.AnyReal) -> _array_1d[_f8]:
    ...

def mathieu_odd_coef(m: spt.AnyInt, q: spt.AnyReal) -> _array_1d[_f8]:
    ...

def lpmn(m: spt.AnyInt, n: spt.AnyInt, z: _ArrayLikeFloat_co) -> _tuple2[_array_2d[_f8]]:
    ...

def clpmn(m: spt.AnyInt, n: spt.AnyInt, z: _ArrayLikeComplex_co, type: Literal[2, 3] = ...) -> _tuple2[_array_2d[_c16]]:
    ...

def lqmn(m: spt.AnyInt, n: spt.AnyInt, z: _ArrayLikeFloat_co) -> _tuple2[_array_2d[_f]] | _tuple2[_array_2d[_c]]:
    ...

def bernoulli(n: spt.AnyInt) -> _array_1d[_f8]:
    ...

def euler(n: spt.AnyInt) -> _array_1d[_f8]:
    ...

def lpn(n: spt.AnyInt, z: spt.AnyReal) -> _tuple2[_array_1d[_f]] | _tuple2[_array_1d[_c]]:
    ...

def lqn(n: spt.AnyInt, z: npt.ArrayLike) -> _tuple2[_array_1d[_f8]] | _tuple2[_array_1d[_c16]]:
    ...

def ai_zeros(nt: spt.AnyInt) -> _tuple4[_array_1d[_f8]]:
    ...

def bi_zeros(nt: spt.AnyInt) -> _tuple4[_array_1d[_f8]]:
    ...

def lmbda(v: spt.AnyReal, x: spt.AnyReal) -> _tuple2[_array_1d[_f8]]:
    ...

def pbdv_seq(v: spt.AnyReal, x: spt.AnyReal) -> _tuple2[_array_1d[_f8]]:
    ...

def pbvv_seq(v: spt.AnyReal, x: spt.AnyReal) -> _tuple2[_array_1d[_f8]]:
    ...

def pbdn_seq(n: spt.AnyInt, z: spt.AnyComplex) -> _tuple2[_array_1d[_c16]]:
    ...

def ber_zeros(nt: spt.AnyInt) -> _array_1d[_f8]:
    ...

def bei_zeros(nt: spt.AnyInt) -> _array_1d[_f8]:
    ...

def ker_zeros(nt: spt.AnyInt) -> _array_1d[_f8]:
    ...

def kei_zeros(nt: spt.AnyInt) -> _array_1d[_f8]:
    ...

def berp_zeros(nt: spt.AnyInt) -> _array_1d[_f8]:
    ...

def beip_zeros(nt: spt.AnyInt) -> _array_1d[_f8]:
    ...

def kerp_zeros(nt: spt.AnyInt) -> _array_1d[_f8]:
    ...

def keip_zeros(nt: spt.AnyInt) -> _array_1d[_f8]:
    ...

def kelvin_zeros(nt: spt.AnyInt) -> _tuple8[_array_1d[_f8]]:
    ...

def pro_cv_seq(m: spt.AnyInt, n: spt.AnyInt, c: spt.AnyReal) -> _array_1d[_f8]:
    ...

def obl_cv_seq(m: spt.AnyInt, n: spt.AnyInt, c: spt.AnyReal) -> _array_1d[_f8]:
    ...

@overload
def comb(N: spt.AnyInt | _array_0d[_i], k: spt.AnyInt | _array_0d[_i], *, exact: Literal[True, 1], repetition: spt.AnyBool = ...) -> int:
    ...

@overload
def comb(N: _ArrayLikeFloat_co, k: _ArrayLikeFloat_co, *, exact: Literal[False, 0, None] = ..., repetition: spt.AnyBool = ...) -> _scalar_or_array[_f4 | _f8]:
    ...

@overload
def perm(N: spt.AnyInt | _array_0d[_i], k: spt.AnyInt | _array_0d[_i], exact: Literal[True, 1]) -> int:
    ...

@overload
def perm(N: _ArrayLikeFloat_co, k: _ArrayLikeFloat_co, exact: Literal[False, 0, None] = ...) -> _scalar_or_array[_f4 | _f8]:
    ...

@overload
def factorial(n: _ArrayLikeInt_co, exact: Literal[True, 1]) -> int | _array[np.int_]:
    ...

@overload
def factorial(n: _ArrayLikeFloat_co, exact: Literal[False, 0, None] = ...) -> _scalar_or_array[_f8]:
    ...

@overload
def factorial2(n: _ArrayLikeInt_co, exact: Literal[True, 1]) -> _i | _array[np.int_]:
    ...

@overload
def factorial2(n: _ArrayLikeInt_co, exact: Literal[False, 0, None] = ...) -> _scalar_or_array[_f8]:
    ...

@overload
def factorialk(n: _ArrayLikeInt_co, k: int | _i, exact: Literal[True, 1]) -> _i | _array[np.int_]:
    ...

@overload
def factorialk(n: _ArrayLikeInt_co, k: int | _i, exact: Literal[False, 0, None] = ...) -> _scalar_or_array[_f8]:
    ...

@overload
def stirling2(N: _ArrayLikeInt_co, K: _ArrayLikeInt_co, *, exact: Literal[True, 1]) -> int | _array[np.object_]:
    ...

@overload
def stirling2(N: _ArrayLikeInt_co, K: _ArrayLikeInt_co, *, exact: Literal[False, 0, None] = ...) -> _scalar_or_array[_f8]:
    ...

@overload
def zeta(x: _ArrayLikeFloat_co, q: _ArrayLikeFloat_co | None, out: _ArrayT) -> _ArrayT:
    ...

@overload
def zeta(x: _ArrayLikeFloat_co, q: _ArrayLikeFloat_co | None = ..., *, out: _ArrayT) -> _ArrayT:
    ...

@overload
def zeta(x: _ArrayLikeFloat_co, q: _ArrayLikeFloat_co | None = ..., out: None = ...) -> _scalar_or_array[_f8]:
    ...

