"""
This type stub file was generated by pyright.
"""

import abc
import numpy as np
import numpy.typing as npt
import optype as op
import optype.numpy as onpt
import scipy._typing as spt
from collections.abc import Sequence
from typing import Any, Final, Generic, Literal, TypeAlias, overload, type_check_only
from typing_extensions import Self, TypeVar, override
from scipy.stats import _covariance
from ._covariance import Covariance

__all__ = ["dirichlet", "dirichlet_multinomial", "invwishart", "matrix_normal", "multinomial", "multivariate_hypergeom", "multivariate_normal", "multivariate_t", "ortho_group", "random_correlation", "random_table", "special_ortho_group", "uniform_direction", "unitary_group", "vonmises_fisher", "wishart"]
_RVG_co = TypeVar("_RVG_co", bound=multi_rv_generic, covariant=True, default=multi_rv_generic)
_RVF_co = TypeVar("_RVF_co", bound=multi_rv_frozen, covariant=True)
_Scalar_uif: TypeAlias = np.integer[Any] | np.floating[Any]
_ArrayLike_uif_1d: TypeAlias = (Sequence[float | _Scalar_uif] | onpt.CanArray[tuple[int], np.dtype[_Scalar_uif]] | npt.NDArray[_Scalar_uif])
_ArrayLike_uif_2d: TypeAlias = (Sequence[_ArrayLike_uif_1d] | onpt.CanArray[tuple[int, int], np.dtype[_Scalar_uif]] | npt.NDArray[_Scalar_uif])
_ArrayLike_uif_2d_max: TypeAlias = spt.AnyReal | _ArrayLike_uif_1d | _ArrayLike_uif_2d
_ArrayLike_uif_nd: TypeAlias = Sequence[float | _ArrayLike_uif_nd] | onpt.CanArray[Any, np.dtype[_Scalar_uif]]
_ArrayLike_ui_nd: TypeAlias = Sequence[int | _ArrayLike_ui_nd] | onpt.CanArray[Any, np.dtype[np.integer[Any]]]
_ArrayLike_f_nd: TypeAlias = Sequence[float | _ArrayLike_f_nd] | onpt.CanArray[Any, np.dtype[np.floating[Any]]]
_ScalarOrArray_f8: TypeAlias = np.float64 | onpt.Array[onpt.AtLeast1D, np.float64]
_AnyCov: TypeAlias = Covariance | _ArrayLike_uif_2d | spt.AnyReal
@type_check_only
class rng_mixin:
    @property
    def random_state(self, /) -> spt.RNG:
        ...
    
    @random_state.setter
    def random_state(self, /, seed: spt.Seed) -> None:
        ...
    


class multi_rv_generic(rng_mixin):
    def __init__(self, /, seed: spt.Seed | None = ...) -> None:
        ...
    
    @abc.abstractmethod
    def __call__(self, /, *args: Any, **kwds: Any) -> multi_rv_frozen[Self]:
        ...
    


class multi_rv_frozen(rng_mixin, Generic[_RVG_co]):
    ...


class multivariate_normal_gen(multi_rv_generic):
    @override
    def __call__(self, /, mean: _ArrayLike_uif_1d | None = ..., cov: _AnyCov = ..., allow_singular: bool = ..., seed: spt.Seed | None = ...) -> multivariate_normal_frozen:
        ...
    
    def logpdf(self, /, x: _ArrayLike_uif_nd, mean: _ArrayLike_uif_1d | None = ..., cov: _AnyCov = ..., allow_singular: bool = ...) -> _ScalarOrArray_f8:
        ...
    
    def pdf(self, /, x: _ArrayLike_uif_nd, mean: _ArrayLike_uif_1d | None = ..., cov: _AnyCov = ..., allow_singular: bool = ...) -> _ScalarOrArray_f8:
        ...
    
    def logcdf(self, /, x: _ArrayLike_uif_nd, mean: _ArrayLike_uif_1d | None = ..., cov: _AnyCov = ..., allow_singular: bool = ..., maxpts: int | None = ..., abseps: float = ..., releps: float = ..., *, lower_limit: _ArrayLike_uif_1d | None = ...) -> _ScalarOrArray_f8:
        ...
    
    def cdf(self, /, x: _ArrayLike_uif_nd, mean: _ArrayLike_uif_1d | None = ..., cov: _AnyCov = ..., allow_singular: bool = ..., maxpts: int | None = ..., abseps: float = ..., releps: float = ..., *, lower_limit: _ArrayLike_uif_1d | None = ...) -> _ScalarOrArray_f8:
        ...
    
    def rvs(self, /, mean: _ArrayLike_uif_1d | None = ..., cov: _AnyCov = ..., size: int | tuple[int, ...] = ..., random_state: spt.Seed | None = ...) -> npt.NDArray[np.float64]:
        ...
    
    def entropy(self, /, mean: _ArrayLike_uif_1d | None = ..., cov: _AnyCov = ...) -> np.float64:
        ...
    
    def fit(self, x: _ArrayLike_uif_nd, fix_mean: _ArrayLike_uif_1d | None = ..., fix_cov: _ArrayLike_uif_2d | None = ...) -> tuple[onpt.Array[tuple[int], np.float64], onpt.Array[tuple[int, int], np.float64]]:
        ...
    


class multivariate_normal_frozen(multi_rv_frozen[multivariate_normal_gen]):
    dim: Final[int]
    allow_singular: Final[bool]
    maxpts: Final[int]
    abseps: Final[float]
    releps: Final[float]
    cov_object: Final[Covariance]
    def __init__(self, /, mean: _ArrayLike_uif_1d | None = ..., cov: _AnyCov = ..., allow_singular: bool = ..., seed: spt.Seed | None = ..., maxpts: int | None = ..., abseps: float = ..., releps: float = ...) -> None:
        ...
    
    @property
    def mean(self, /) -> onpt.Array[tuple[int], np.float64]:
        ...
    
    @property
    def cov(self, /) -> onpt.Array[tuple[int, int], np.float64]:
        ...
    
    def logpdf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def pdf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def logcdf(self, /, x: _ArrayLike_uif_nd, *, lower_limit: _ArrayLike_uif_1d | None = ...) -> _ScalarOrArray_f8:
        ...
    
    def cdf(self, /, x: _ArrayLike_uif_nd, *, lower_limit: _ArrayLike_uif_1d | None = ...) -> _ScalarOrArray_f8:
        ...
    
    def rvs(self, /, size: int | tuple[int, ...] = ..., random_state: spt.Seed | None = ...) -> npt.NDArray[np.float64]:
        ...
    
    def entropy(self, /) -> np.float64:
        ...
    


class matrix_normal_gen(multi_rv_generic):
    @override
    def __call__(self, /, mean: _ArrayLike_uif_2d | None = ..., rowcov: _ArrayLike_uif_2d | spt.AnyReal = ..., colcov: _ArrayLike_uif_2d | spt.AnyReal = ..., seed: spt.Seed | None = ...) -> matrix_normal_frozen:
        ...
    
    def logpdf(self, /, X: _ArrayLike_uif_nd, mean: _ArrayLike_uif_2d | None = ..., rowcov: _ArrayLike_uif_2d | spt.AnyReal = ..., colcov: _ArrayLike_uif_2d | spt.AnyReal = ...) -> _ScalarOrArray_f8:
        ...
    
    def pdf(self, /, X: _ArrayLike_uif_nd, mean: _ArrayLike_uif_2d | None = ..., rowcov: _ArrayLike_uif_2d | spt.AnyReal = ..., colcov: _ArrayLike_uif_2d | spt.AnyReal = ...) -> _ScalarOrArray_f8:
        ...
    
    def rvs(self, /, mean: _ArrayLike_uif_2d | None = ..., rowcov: _ArrayLike_uif_2d | spt.AnyReal = ..., colcov: _ArrayLike_uif_2d | spt.AnyReal = ..., size: op.typing.AnyInt = ..., random_state: spt.Seed | None = ...) -> onpt.Array[tuple[int, int, int], np.float64]:
        ...
    
    def entropy(self, /, rowcov: _AnyCov = ..., colcov: _AnyCov = ...) -> np.float64:
        ...
    


class matrix_normal_frozen(multi_rv_frozen[matrix_normal_gen]):
    rowpsd: Final[_covariance._PSD]
    colpsd: Final[_covariance._PSD]
    def __init__(self, mean: _ArrayLike_uif_2d | None = ..., rowcov: _ArrayLike_uif_2d | spt.AnyReal = ..., colcov: _ArrayLike_uif_2d | spt.AnyReal = ..., seed: spt.Seed | None = ...) -> None:
        ...
    
    def logpdf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def pdf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def rvs(self, /, size: op.typing.AnyInt = ..., random_state: spt.Seed | None = ...) -> onpt.Array[tuple[int, int, int], np.float64]:
        ...
    
    def entropy(self, /) -> np.float64:
        ...
    


class dirichlet_gen(multi_rv_generic):
    @override
    def __call__(self, /, alpha: _ArrayLike_uif_1d, seed: spt.Seed | None = ...) -> dirichlet_frozen:
        ...
    
    def logpdf(self, /, x: _ArrayLike_uif_nd, alpha: _ArrayLike_uif_1d) -> _ScalarOrArray_f8:
        ...
    
    def pdf(self, /, x: _ArrayLike_uif_nd, alpha: _ArrayLike_uif_1d) -> _ScalarOrArray_f8:
        ...
    
    def mean(self, /, alpha: _ArrayLike_uif_1d) -> onpt.Array[tuple[int], np.float64]:
        ...
    
    def var(self, /, alpha: _ArrayLike_uif_1d) -> onpt.Array[tuple[int], np.float64]:
        ...
    
    def cov(self, /, alpha: _ArrayLike_uif_1d) -> onpt.Array[tuple[int, int], np.float64]:
        ...
    
    def entropy(self, /, alpha: _ArrayLike_uif_1d) -> np.float64:
        ...
    
    @overload
    def rvs(self, /, alpha: _ArrayLike_uif_1d, size: tuple[()], random_state: spt.Seed | None = ...) -> onpt.Array[tuple[int], np.float64]:
        ...
    
    @overload
    def rvs(self, /, alpha: _ArrayLike_uif_1d, size: int | tuple[int] = ..., random_state: spt.Seed | None = ...) -> onpt.Array[tuple[int, int], np.float64]:
        ...
    
    @overload
    def rvs(self, /, alpha: _ArrayLike_uif_1d, size: tuple[int, int], random_state: spt.Seed | None = ...) -> onpt.Array[tuple[int, int, int], np.float64]:
        ...
    
    @overload
    def rvs(self, /, alpha: _ArrayLike_uif_1d, size: onpt.AtLeast2D, random_state: spt.Seed | None = ...) -> onpt.Array[onpt.AtLeast3D, np.float64]:
        ...
    


class dirichlet_frozen(multi_rv_frozen[dirichlet_gen]):
    alpha: Final[onpt.Array[tuple[int], _Scalar_uif]]
    def __init__(self, /, alpha: _ArrayLike_uif_1d, seed: spt.Seed | None = ...) -> None:
        ...
    
    def logpdf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def pdf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def mean(self, /) -> onpt.Array[tuple[int], np.float64]:
        ...
    
    def var(self, /) -> onpt.Array[tuple[int], np.float64]:
        ...
    
    def cov(self, /) -> onpt.Array[tuple[int, int], np.float64]:
        ...
    
    def entropy(self, /) -> np.float64:
        ...
    
    @overload
    def rvs(self, /, size: tuple[()], random_state: spt.Seed | None = ...) -> onpt.Array[tuple[int], np.float64]:
        ...
    
    @overload
    def rvs(self, /, size: int | tuple[int] = ..., random_state: spt.Seed | None = ...) -> onpt.Array[tuple[int, int], np.float64]:
        ...
    
    @overload
    def rvs(self, /, size: tuple[int, int], random_state: spt.Seed | None = ...) -> onpt.Array[tuple[int, int, int], np.float64]:
        ...
    
    @overload
    def rvs(self, /, size: onpt.AtLeast2D, random_state: spt.Seed | None = ...) -> onpt.Array[onpt.AtLeast3D, np.float64]:
        ...
    


class wishart_gen(multi_rv_generic):
    @override
    def __call__(self, /, df: spt.AnyReal | None = ..., scale: _ArrayLike_uif_2d_max | None = ..., seed: spt.Seed | None = ...) -> wishart_frozen:
        ...
    
    def logpdf(self, /, x: _ArrayLike_uif_nd, df: spt.AnyReal, scale: _ArrayLike_uif_2d_max) -> _ScalarOrArray_f8:
        ...
    
    def pdf(self, /, x: _ArrayLike_uif_nd, df: spt.AnyReal, scale: _ArrayLike_uif_2d_max) -> _ScalarOrArray_f8:
        ...
    
    def mean(self, /, df: spt.AnyReal, scale: _ArrayLike_uif_2d_max) -> np.float64 | onpt.Array[tuple[int, int], np.float64]:
        ...
    
    def mode(self, /, df: spt.AnyReal, scale: _ArrayLike_uif_2d_max) -> np.float64 | None:
        ...
    
    def var(self, /, df: spt.AnyReal, scale: _ArrayLike_uif_2d_max) -> np.float64 | onpt.Array[tuple[int, int], np.float64]:
        ...
    
    def rvs(self, /, df: spt.AnyReal, scale: _ArrayLike_uif_2d_max, size: int | tuple[int, ...] = ..., random_state: spt.Seed | None = ...) -> _ScalarOrArray_f8:
        ...
    
    def entropy(self, /, df: spt.AnyReal, scale: _ArrayLike_uif_2d_max) -> np.float64:
        ...
    


class wishart_frozen(multi_rv_frozen[wishart_gen]):
    dim: Final[int]
    df: Final[spt.AnyReal]
    scale: Final[onpt.Array[tuple[int, int], np.float64]]
    C: Final[onpt.Array[tuple[int, int], np.float64]]
    log_det_scale: Final[float]
    def __init__(self, df: spt.AnyReal, scale: _ArrayLike_uif_2d_max, seed: spt.Seed | None = ...) -> None:
        ...
    
    def logpdf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def pdf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def mean(self, /) -> np.float64 | onpt.Array[tuple[int, int], np.float64]:
        ...
    
    def mode(self, /) -> np.float64 | None:
        ...
    
    def var(self, /) -> np.float64 | onpt.Array[tuple[int, int], np.float64]:
        ...
    
    def rvs(self, /, size: int | onpt.AtLeast1D = ..., random_state: spt.Seed | None = ...) -> _ScalarOrArray_f8:
        ...
    
    def entropy(self, /) -> np.float64:
        ...
    


class invwishart_gen(wishart_gen):
    @override
    def __call__(self, /, df: spt.AnyReal | None = ..., scale: _ArrayLike_uif_2d_max | None = ..., seed: spt.Seed | None = ...) -> invwishart_frozen:
        ...
    
    @override
    def mean(self, /, df: spt.AnyReal, scale: _ArrayLike_uif_2d_max) -> np.float64 | None:
        ...
    
    @override
    def mode(self, /, df: spt.AnyReal, scale: _ArrayLike_uif_2d_max) -> np.float64 | onpt.Array[tuple[int, int], np.float64]:
        ...
    
    @override
    def var(self, /, df: spt.AnyReal, scale: _ArrayLike_uif_2d_max) -> np.float64 | None:
        ...
    


class invwishart_frozen(multi_rv_frozen[invwishart_gen]):
    def __init__(self, /, df: spt.AnyReal, scale: _ArrayLike_uif_2d_max, seed: spt.Seed | None = ...) -> None:
        ...
    
    def logpdf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def pdf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def mean(self, /) -> np.float64 | onpt.Array[tuple[int, int], np.float64]:
        ...
    
    def mode(self, /) -> np.float64 | None:
        ...
    
    def var(self, /) -> np.float64 | onpt.Array[tuple[int, int], np.float64]:
        ...
    
    def rvs(self, /, size: int | tuple[int, ...] = ..., random_state: spt.Seed | None = ...) -> npt.NDArray[np.float64]:
        ...
    
    def entropy(self, /) -> np.float64:
        ...
    


class multinomial_gen(multi_rv_generic):
    @override
    def __call__(self, /, n: onpt.AnyIntegerArray, p: _ArrayLike_f_nd, seed: spt.Seed | None = ...) -> multinomial_frozen:
        ...
    
    def logpmf(self, /, x: _ArrayLike_uif_nd, n: onpt.AnyIntegerArray, p: _ArrayLike_f_nd) -> _ScalarOrArray_f8:
        ...
    
    def pmf(self, /, x: _ArrayLike_uif_nd, n: onpt.AnyIntegerArray, p: _ArrayLike_f_nd) -> _ScalarOrArray_f8:
        ...
    
    def mean(self, /, n: onpt.AnyIntegerArray, p: _ArrayLike_f_nd) -> onpt.Array[onpt.AtLeast1D, np.float64]:
        ...
    
    def cov(self, /, n: onpt.AnyIntegerArray, p: _ArrayLike_f_nd) -> onpt.Array[onpt.AtLeast2D, np.float64]:
        ...
    
    def entropy(self, /, n: onpt.AnyIntegerArray, p: _ArrayLike_f_nd) -> _ScalarOrArray_f8:
        ...
    
    @overload
    def rvs(self, /, n: onpt.AnyIntegerArray, p: _ArrayLike_f_nd, size: tuple[()], random_state: spt.Seed | None = ...) -> onpt.Array[onpt.AtLeast1D]:
        ...
    
    @overload
    def rvs(self, /, n: onpt.AnyIntegerArray, p: _ArrayLike_f_nd, size: int | onpt.AtLeast1D | None = ..., random_state: spt.Seed | None = ...) -> onpt.Array[onpt.AtLeast2D]:
        ...
    


class multinomial_frozen(multi_rv_frozen[multinomial_gen]):
    def __init__(self, /, n: onpt.AnyIntegerArray, p: _ArrayLike_f_nd, seed: spt.Seed | None = ...) -> None:
        ...
    
    def logpmf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def pmf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def mean(self, /) -> onpt.Array[onpt.AtLeast1D, np.float64]:
        ...
    
    def cov(self, /) -> onpt.Array[onpt.AtLeast2D, np.float64]:
        ...
    
    def entropy(self, /) -> _ScalarOrArray_f8:
        ...
    
    @overload
    def rvs(self, /, size: tuple[()], random_state: spt.Seed | None = ...) -> onpt.Array[onpt.AtLeast1D, np.float64]:
        ...
    
    @overload
    def rvs(self, /, size: onpt.AtLeast1D | int = ..., random_state: spt.Seed | None = ...) -> onpt.Array[onpt.AtLeast2D, np.float64]:
        ...
    


@type_check_only
class _group_rv_gen_mixin(Generic[_RVF_co]):
    def __call__(self, /, dim: spt.AnyInt | None = ..., seed: spt.Seed | None = ...) -> _RVF_co:
        ...
    
    def rvs(self, /, dim: spt.AnyInt, size: int = ..., random_state: spt.Seed | None = ...) -> onpt.Array[tuple[int, int, int], np.float64]:
        ...
    


@type_check_only
class _group_rv_frozen_mixin:
    dim: spt.AnyInt
    def __init__(self, /, dim: spt.AnyInt | None = ..., seed: spt.Seed | None = ...) -> None:
        ...
    
    def rvs(self, /, size: int = ..., random_state: spt.Seed | None = ...) -> onpt.Array[tuple[int, int, int], np.float64]:
        ...
    


class special_ortho_group_gen(_group_rv_gen_mixin[special_ortho_group_frozen], multi_rv_generic):
    ...


class special_ortho_group_frozen(_group_rv_frozen_mixin, multi_rv_frozen[special_ortho_group_gen]):
    ...


class ortho_group_gen(_group_rv_gen_mixin[ortho_group_frozen], multi_rv_generic):
    ...


class ortho_group_frozen(_group_rv_frozen_mixin, multi_rv_frozen[ortho_group_gen]):
    ...


class unitary_group_gen(_group_rv_gen_mixin[unitary_group_frozen], multi_rv_generic):
    ...


class unitary_group_frozen(_group_rv_frozen_mixin, multi_rv_frozen[unitary_group_gen]):
    ...


class uniform_direction_gen(_group_rv_gen_mixin[uniform_direction_frozen], multi_rv_generic):
    ...


class uniform_direction_frozen(_group_rv_frozen_mixin, multi_rv_frozen[uniform_direction_gen]):
    ...


class random_correlation_gen(multi_rv_generic):
    @override
    def __call__(self, /, eigs: _ArrayLike_uif_1d, seed: spt.Seed | None = ..., tol: float = ..., diag_tol: float = ...) -> random_correlation_frozen:
        ...
    
    def rvs(self, /, eigs: _ArrayLike_uif_1d, random_state: spt.Seed | None = ..., tol: float = ..., diag_tol: float = ...) -> npt.NDArray[np.float64]:
        ...
    


class random_correlation_frozen(multi_rv_frozen[random_correlation_gen]):
    tol: Final[float]
    diag_tol: Final[float]
    eigs: Final[onpt.Array[tuple[int], np.float64]]
    def __init__(self, /, eigs: _ArrayLike_uif_1d, seed: spt.Seed | None = ..., tol: float = ..., diag_tol: float = ...) -> None:
        ...
    
    def rvs(self, /, random_state: spt.Seed | None = ...) -> npt.NDArray[np.float64]:
        ...
    


class multivariate_t_gen(multi_rv_generic):
    @override
    def __call__(self, /, loc: _ArrayLike_uif_1d | None = ..., shape: spt.AnyReal | _ArrayLike_uif_2d = ..., df: int = ..., allow_singular: bool = ..., seed: spt.Seed | None = ...) -> multivariate_t_frozen:
        ...
    
    def pdf(self, /, x: _ArrayLike_uif_nd, loc: _ArrayLike_uif_1d | None = ..., shape: spt.AnyReal | _ArrayLike_uif_2d = ..., df: int = ..., allow_singular: bool = ...) -> _ScalarOrArray_f8:
        ...
    
    def logpdf(self, /, x: _ArrayLike_uif_nd, loc: _ArrayLike_uif_1d | None = ..., shape: spt.AnyReal | _ArrayLike_uif_2d = ..., df: int = ...) -> _ScalarOrArray_f8:
        ...
    
    def cdf(self, /, x: _ArrayLike_uif_nd, loc: _ArrayLike_uif_1d | None = ..., shape: spt.AnyReal | _ArrayLike_uif_2d = ..., df: int = ..., allow_singular: bool = ..., *, maxpts: int | None = ..., lower_limit: _ArrayLike_uif_1d | None = ..., random_state: spt.Seed | None = ...) -> _ScalarOrArray_f8:
        ...
    
    def entropy(self, /, loc: _ArrayLike_uif_1d | None = ..., shape: spt.AnyReal | _ArrayLike_uif_2d = ..., df: int = ...) -> np.float64:
        ...
    
    @overload
    def rvs(self, /, loc: _ArrayLike_uif_1d | None = ..., shape: spt.AnyReal | _ArrayLike_uif_2d = ..., df: int = ..., *, size: tuple[()], random_state: spt.Seed | None = ...) -> onpt.Array[tuple[int], np.float64]:
        ...
    
    @overload
    def rvs(self, loc: _ArrayLike_uif_1d | None, shape: spt.AnyReal | _ArrayLike_uif_2d, df: int, /, size: tuple[()], random_state: spt.Seed | None = ...) -> onpt.Array[tuple[int], np.float64]:
        ...
    
    @overload
    def rvs(self, /, loc: _ArrayLike_uif_1d | None = ..., shape: spt.AnyReal | _ArrayLike_uif_2d = ..., df: int = ..., size: int | tuple[int] = ..., random_state: spt.Seed | None = ...) -> onpt.Array[tuple[int, int], np.float64]:
        ...
    
    @overload
    def rvs(self, /, loc: _ArrayLike_uif_1d | None = ..., shape: spt.AnyReal | _ArrayLike_uif_2d = ..., df: int = ..., *, size: onpt.AtLeast2D, random_state: spt.Seed | None = ...) -> onpt.Array[onpt.AtLeast3D, np.float64]:
        ...
    
    @overload
    def rvs(self, loc: _ArrayLike_uif_1d | None, shape: spt.AnyReal | _ArrayLike_uif_2d, df: int, /, size: onpt.AtLeast2D, random_state: spt.Seed | None = ...) -> onpt.Array[onpt.AtLeast3D, np.float64]:
        ...
    


class multivariate_t_frozen(multi_rv_frozen[multivariate_t_gen]):
    dim: Final[int]
    loc: Final[onpt.Array[tuple[int], np.float64]]
    shape: Final[onpt.Array[tuple[int, int], np.float64]]
    df: Final[int]
    shape_info: Final[_covariance._PSD]
    def __init__(self, /, loc: _ArrayLike_uif_1d | None = ..., shape: spt.AnyReal | _ArrayLike_uif_2d = ..., df: int = ..., allow_singular: bool = ..., seed: spt.Seed | None = ...) -> None:
        ...
    
    def logpdf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def pdf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def cdf(self, /, x: _ArrayLike_uif_nd, *, maxpts: int | None = ..., lower_limit: _ArrayLike_uif_1d | None = ..., random_state: spt.Seed | None = ...) -> _ScalarOrArray_f8:
        ...
    
    def entropy(self, /) -> np.float64:
        ...
    
    @overload
    def rvs(self, /, size: tuple[()], random_state: spt.Seed | None = ...) -> onpt.Array[tuple[int], np.float64]:
        ...
    
    @overload
    def rvs(self, /, size: int | tuple[int] = ..., random_state: spt.Seed | None = ...) -> onpt.Array[tuple[int, int], np.float64]:
        ...
    
    @overload
    def rvs(self, /, size: onpt.AtLeast2D, random_state: spt.Seed | None = ...) -> onpt.Array[onpt.AtLeast3D, np.float64]:
        ...
    


class multivariate_hypergeom_gen(multi_rv_generic):
    @override
    def __call__(self, /, m: _ArrayLike_ui_nd, n: int | _ArrayLike_ui_nd, seed: spt.Seed | None = ...) -> multivariate_hypergeom_frozen:
        ...
    
    def logpmf(self, /, x: _ArrayLike_uif_nd, m: _ArrayLike_ui_nd, n: int | _ArrayLike_ui_nd) -> _ScalarOrArray_f8:
        ...
    
    def pmf(self, /, x: _ArrayLike_uif_nd, m: _ArrayLike_ui_nd, n: int | _ArrayLike_ui_nd) -> _ScalarOrArray_f8:
        ...
    
    def mean(self, /, m: _ArrayLike_ui_nd, n: int | _ArrayLike_ui_nd) -> onpt.Array[onpt.AtLeast1D, np.float64]:
        ...
    
    def var(self, /, m: _ArrayLike_ui_nd, n: int | _ArrayLike_ui_nd) -> onpt.Array[onpt.AtLeast1D, np.float64]:
        ...
    
    def cov(self, /, m: _ArrayLike_ui_nd, n: int | _ArrayLike_ui_nd) -> onpt.Array[onpt.AtLeast2D, np.float64]:
        ...
    
    @overload
    def rvs(self, /, m: _ArrayLike_ui_nd, n: int | _ArrayLike_ui_nd, size: tuple[()], random_state: spt.Seed | None = ...) -> onpt.Array[onpt.AtLeast1D, np.float64]:
        ...
    
    @overload
    def rvs(self, /, m: _ArrayLike_ui_nd, n: int | _ArrayLike_ui_nd, size: int | onpt.AtLeast1D | None = ..., random_state: spt.Seed | None = ...) -> onpt.Array[onpt.AtLeast2D, np.float64]:
        ...
    


class multivariate_hypergeom_frozen(multi_rv_frozen[multivariate_hypergeom_gen]):
    def __init__(self, /, m: _ArrayLike_ui_nd, n: int | _ArrayLike_ui_nd, seed: spt.Seed | None = ...) -> None:
        ...
    
    def logpmf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def pmf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def mean(self, /) -> onpt.Array[onpt.AtLeast1D, np.float64]:
        ...
    
    def var(self, /) -> onpt.Array[onpt.AtLeast1D, np.float64]:
        ...
    
    def cov(self, /) -> onpt.Array[onpt.AtLeast2D, np.float64]:
        ...
    
    @overload
    def rvs(self, /, size: tuple[()], random_state: spt.Seed | None = ...) -> onpt.Array[onpt.AtLeast1D, np.float64]:
        ...
    
    @overload
    def rvs(self, /, size: int | onpt.AtLeast1D = ..., random_state: spt.Seed | None = ...) -> onpt.Array[onpt.AtLeast2D, np.float64]:
        ...
    


_RandomTableRVSMethod: TypeAlias = Literal["boyett", "patefield"]
class random_table_gen(multi_rv_generic):
    @override
    def __call__(self, /, row: _ArrayLike_ui_nd, col: _ArrayLike_ui_nd, *, seed: spt.Seed | None = ...) -> random_table_frozen:
        ...
    
    def logpmf(self, /, x: _ArrayLike_uif_nd, row: _ArrayLike_ui_nd, col: _ArrayLike_ui_nd) -> _ScalarOrArray_f8:
        ...
    
    def pmf(self, /, x: _ArrayLike_uif_nd, row: _ArrayLike_ui_nd, col: _ArrayLike_ui_nd) -> _ScalarOrArray_f8:
        ...
    
    def mean(self, /, row: _ArrayLike_ui_nd, col: _ArrayLike_ui_nd) -> onpt.Array[tuple[int, int], np.float64]:
        ...
    
    def rvs(self, /, row: _ArrayLike_ui_nd, col: _ArrayLike_ui_nd, *, size: int | None = ..., method: _RandomTableRVSMethod | None = ..., random_state: spt.Seed | None = ...) -> onpt.Array[tuple[int, int, int], np.float64]:
        ...
    


class random_table_frozen(multi_rv_frozen[random_table_gen]):
    def __init__(self, /, row: _ArrayLike_ui_nd, col: _ArrayLike_ui_nd, *, seed: spt.Seed | None = ...) -> None:
        ...
    
    def logpmf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def pmf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def mean(self, /) -> onpt.Array[tuple[int, int], np.float64]:
        ...
    
    def rvs(self, /, size: int | None = ..., method: _RandomTableRVSMethod | None = ..., random_state: spt.Seed | None = ...) -> onpt.Array[tuple[int, int, int], np.float64]:
        ...
    


class dirichlet_multinomial_gen(multi_rv_generic):
    @override
    def __call__(self, /, alpha: _ArrayLike_uif_nd, n: onpt.AnyIntegerArray, seed: spt.Seed | None = ...) -> dirichlet_multinomial_frozen:
        ...
    
    def logpmf(self, /, x: _ArrayLike_ui_nd, alpha: _ArrayLike_uif_nd, n: onpt.AnyIntegerArray) -> _ScalarOrArray_f8:
        ...
    
    def pmf(self, /, x: _ArrayLike_ui_nd, alpha: _ArrayLike_uif_nd, n: onpt.AnyIntegerArray) -> _ScalarOrArray_f8:
        ...
    
    def mean(self, /, alpha: _ArrayLike_uif_nd, n: onpt.AnyIntegerArray) -> onpt.Array[onpt.AtLeast1D, np.float64]:
        ...
    
    def var(self, /, alpha: _ArrayLike_uif_nd, n: onpt.AnyIntegerArray) -> onpt.Array[onpt.AtLeast1D, np.float64]:
        ...
    
    def cov(self, /, alpha: _ArrayLike_uif_nd, n: onpt.AnyIntegerArray) -> onpt.Array[onpt.AtLeast2D, np.float64]:
        ...
    


class dirichlet_multinomial_frozen(multi_rv_frozen[dirichlet_multinomial_gen]):
    alpha: onpt.Array[onpt.AtLeast1D, np.float64]
    n: onpt.Array[onpt.AtLeast1D, np.int_]
    def __init__(self, /, alpha: _ArrayLike_uif_nd, n: onpt.AnyIntegerArray, seed: spt.Seed | None = ...) -> None:
        ...
    
    def logpmf(self, /, x: _ArrayLike_ui_nd) -> _ScalarOrArray_f8:
        ...
    
    def pmf(self, /, x: _ArrayLike_ui_nd) -> _ScalarOrArray_f8:
        ...
    
    def mean(self, /) -> onpt.Array[onpt.AtLeast1D, np.float64]:
        ...
    
    def var(self, /) -> onpt.Array[onpt.AtLeast1D, np.float64]:
        ...
    
    def cov(self, /) -> onpt.Array[onpt.AtLeast2D, np.float64]:
        ...
    


class vonmises_fisher_gen(multi_rv_generic):
    @override
    def __call__(self, /, mu: _ArrayLike_uif_1d | None = ..., kappa: int = ..., seed: spt.Seed | None = ...) -> vonmises_fisher_frozen:
        ...
    
    def logpdf(self, /, x: _ArrayLike_uif_nd, mu: _ArrayLike_uif_1d | None = ..., kappa: int = ...) -> _ScalarOrArray_f8:
        ...
    
    def pdf(self, /, x: _ArrayLike_uif_nd, mu: _ArrayLike_uif_1d | None = ..., kappa: int = ...) -> _ScalarOrArray_f8:
        ...
    
    def entropy(self, /, mu: _ArrayLike_uif_1d | None = ..., kappa: int = ...) -> np.float64:
        ...
    
    def rvs(self, /, mu: _ArrayLike_uif_1d | None = ..., kappa: int = ..., size: int | onpt.AtLeast1D = ..., random_state: spt.Seed | None = ...) -> onpt.Array[onpt.AtLeast2D, np.float64]:
        ...
    
    def fit(self, /, x: _ArrayLike_uif_nd) -> tuple[onpt.Array[tuple[int], np.float64], float]:
        ...
    


class vonmises_fisher_frozen(multi_rv_frozen[vonmises_fisher_gen]):
    def __init__(self, /, mu: _ArrayLike_uif_1d | None = ..., kappa: int = ..., seed: spt.Seed | None = ...) -> None:
        ...
    
    def logpdf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def pdf(self, /, x: _ArrayLike_uif_nd) -> _ScalarOrArray_f8:
        ...
    
    def entropy(self, /) -> np.float64:
        ...
    
    def rvs(self, /, size: int | onpt.AtLeast1D = ..., random_state: spt.Seed | None = ...) -> onpt.Array[onpt.AtLeast2D, np.float64]:
        ...
    


multivariate_normal: Final[multivariate_normal_gen]
matrix_normal: Final[matrix_normal_gen]
dirichlet: Final[dirichlet_gen]
wishart: Final[wishart_gen]
invwishart: Final[invwishart_gen]
multinomial: Final[multinomial_gen]
special_ortho_group: Final[special_ortho_group_gen]
ortho_group: Final[ortho_group_gen]
random_correlation: Final[random_correlation_gen]
unitary_group: Final[unitary_group_gen]
multivariate_t: Final[multivariate_t_gen]
multivariate_hypergeom: Final[multivariate_hypergeom_gen]
random_table: Final[random_table_gen]
uniform_direction: Final[uniform_direction_gen]
dirichlet_multinomial: Final[dirichlet_multinomial_gen]
vonmises_fisher: Final[vonmises_fisher_gen]
